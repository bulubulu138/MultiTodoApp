# 时间排序分组位置修复说明

## 修复日期
2025-10-29

## 问题描述

### 用户反馈

在按创建时间升序排序时，发现并列分组的待办被错误地排到了列表最后：

**实际排序结果**（创建时间升序）：
```
位置 0-38: ID 1-45（创建时间从早到晚，正常）
位置 39: ID 31 (创建时间: 2025-10-23T01:13:19) ❌ 应在位置 30
位置 40: ID 34 (创建时间: 2025-10-23T01:39:59) ❌ 并列组
位置 41: ID 42 (创建时间: 2025-10-27T03:23:09) ❌ 应在位置 41
位置 42: ID 43 (创建时间: 2025-10-27T03:23:26) ❌ 并列组
```

**期望的正确排序**：
```
位置 0-29: ID 1-30（按创建时间）
位置 30: ID 31 (2025-10-23T01:13:19) ✅ 在 ID 32 之前
位置 31: ID 34 (2025-10-23T01:39:59) ✅ 并列组
位置 32: ID 32 (2025-10-23T01:16:46)
位置 33: ID 33 (2025-10-23T01:17:25)
...
位置 40: ID 40 (2025-10-27T01:18:52)
位置 41: ID 42 (2025-10-27T03:23:09) ✅ 在 ID 44 之前
位置 42: ID 43 (2025-10-27T03:23:26) ✅ 并列组
位置 43: ID 44 (2025-10-27T03:46:48)
```

### 问题分析

从日志可以看到：
- **4 个并列分组**：ID 31+34, 42+43（共 2 组，每组 2 个待办）
- **groupRepresentatives size: 2**（正确）
- 但这 2 组被排到了最后，而不是按创建时间插入

## 根本原因

### 代码分析

在 `src/renderer/utils/sortWithGroups.ts` 的分组逻辑中（修复前 line 96-105）：

```typescript
const grouped = new Map<Set<number> | null, Todo[]>();

for (const todo of todos) {
  const group = groups.get(todo.id!) || null;  // ❌ 关键问题
  if (!grouped.has(group)) {
    grouped.set(group, []);
  }
  grouped.get(group)!.push(todo);
}
```

### 问题详解

**分组结果**：

`buildParallelGroups` 函数返回的 `groups` Map：
```typescript
Map {
  31 => Set{31, 34},
  34 => Set{31, 34},
  42 => Set{42, 43},
  43 => Set{42, 43}
}
```

对于无并列关系的待办（如 ID 1-30, 32-41, 44-45），`groups.get(todo.id!)` 返回 `undefined`。

**分组过程**：
```typescript
for (const todo of todos) {
  const group = groups.get(todo.id!) || null;
  // ID 1: groups.get(1) = undefined => group = null
  // ID 2: groups.get(2) = undefined => group = null
  // ...
  // ID 30: groups.get(30) = undefined => group = null
  // ID 31: groups.get(31) = Set{31, 34} => group = Set{31, 34}
  // ID 32: groups.get(32) = undefined => group = null
  // ...
}
```

**实际的 `grouped` Map**：
```typescript
Map {
  null => [todo1, todo2, ..., todo30, todo32, ..., todo45],  // 所有无并列关系的
  Set{31, 34} => [todo31, todo34],
  Set{42, 43} => [todo42, todo43]
}
```

**组间排序逻辑**（修复前 line 113-119）：
```typescript
const sortedGroups = Array.from(grouped.entries()).sort(
  ([groupA, todosA], [groupB, todosB]) => {
    const repA = groupA ? representatives.get(groupA)! : todosA[0];
    const repB = groupB ? representatives.get(groupB)! : todosB[0];
    return compareFn(repA, repB);
  }
);
```

**排序过程**：
- **`null` 组**：`groupA = null`，使用 `todosA[0]`（即 ID 1）作为代表
  - ID 1 创建时间：`2025-10-21 01:02:29`（最早）
- **`Set{31, 34}` 组**：使用代表 ID 31
  - ID 31 创建时间：`2025-10-23T01:13:19`
- **`Set{42, 43}` 组**：使用代表 ID 42
  - ID 42 创建时间：`2025-10-27T03:23:09`

**排序结果**：
1. `null` 组（代表 ID 1，最早）
2. `Set{31, 34}` 组（代表 ID 31）
3. `Set{42, 43}` 组（代表 ID 42）

**问题**：`null` 组包含了除 ID 31, 34, 42, 43 外的所有待办（ID 1-30, 32-41, 44-45），这个大组被作为一个整体排序，导致其内部的 ID 32-41 和 44-45 无法与并列组正确穿插。

## 修复方案

### 核心思路

**将每个非并列待办也单独成组**，确保：
- 有并列关系的待办共享一个 Set
- 无并列关系的待办各自独立成一个 Set
- 所有待办都能作为独立单位参与全局排序

### 代码修改

**文件**: `src/renderer/utils/sortWithGroups.ts`

#### 修改 1: 分组逻辑（line 96-112）

**修改前**:
```typescript
const grouped = new Map<Set<number> | null, Todo[]>();

for (const todo of todos) {
  const group = groups.get(todo.id!) || null;  // ❌ 无并列的都是 null
  if (!grouped.has(group)) {
    grouped.set(group, []);
  }
  grouped.get(group)!.push(todo);
}
```

**修改后**:
```typescript
const grouped = new Map<Set<number>, Todo[]>();
const allRepresentatives = new Map(representatives); // 复制现有代表

for (const todo of todos) {
  let group = groups.get(todo.id!);
  if (!group) {
    // 无并列关系：创建只包含自己的 Set
    group = new Set([todo.id!]);
    // 为这个单独的待办设置代表（就是它自己）
    allRepresentatives.set(group, todo);
  }
  if (!grouped.has(group)) {
    grouped.set(group, []);
  }
  grouped.get(group)!.push(todo);
}
```

**关键改进**：
1. 将类型从 `Map<Set<number> | null, Todo[]>` 改为 `Map<Set<number>, Todo[]>`
2. 为无并列关系的待办创建单独的 `Set([todo.id!])`
3. 立即为这个新 Set 设置代表（待办本身）

#### 修改 2: 组间排序逻辑（line 119-126）

**修改前**:
```typescript
const sortedGroups = Array.from(grouped.entries()).sort(
  ([groupA, todosA], [groupB, todosB]) => {
    const repA = groupA ? representatives.get(groupA)! : todosA[0];
    const repB = groupB ? representatives.get(groupB)! : todosB[0];
    return compareFn(repA, repB);
  }
);
```

**修改后**:
```typescript
const sortedGroups = Array.from(grouped.entries()).sort(
  ([groupA, todosA], [groupB, todosB]) => {
    const repA = allRepresentatives.get(groupA)!;
    const repB = allRepresentatives.get(groupB)!;
    return compareFn(repA, repB);
  }
);
```

**关键改进**：
1. 移除对 `null` 的特殊判断（`groupA ?`）
2. 所有组都从 `allRepresentatives` 获取代表
3. 简化逻辑，统一处理

### 修复后的执行流程

**分组结果**（修复后的 `grouped` Map）：
```typescript
Map {
  Set{1} => [todo1],
  Set{2} => [todo2],
  ...
  Set{30} => [todo30],
  Set{31, 34} => [todo31, todo34],  // 并列组
  Set{32} => [todo32],
  ...
  Set{41} => [todo41],
  Set{42, 43} => [todo42, todo43],  // 并列组
  Set{44} => [todo44],
  Set{45} => [todo45]
}
```

**代表 Map**（`allRepresentatives`）：
```typescript
Map {
  Set{1} => todo1,      // 自己是代表
  Set{2} => todo2,      // 自己是代表
  ...
  Set{30} => todo30,    // 自己是代表
  Set{31, 34} => todo31,  // 组代表（创建时间最早）
  Set{32} => todo32,    // 自己是代表
  ...
  Set{42, 43} => todo42,  // 组代表（创建时间最早）
  ...
}
```

**组间排序**：
- 每个组（无论单待办或并列组）都按其代表的创建时间排序
- ID 31+34 组按 ID 31 的创建时间排序，插入到正确位置
- ID 42+43 组按 ID 42 的创建时间排序，插入到正确位置

## 预期效果

### 创建时间升序排序

```
位置 0: ID 1 (2025-10-21 01:02:29)
位置 1: ID 2 (2025-10-22 00:57:03)
...
位置 29: ID 30 (2025-10-22 02:01:44)
位置 30: ID 31 (2025-10-23T01:13:19) ✅ 并列组代表
位置 31: ID 34 (2025-10-23T01:39:59) ✅ 并列组成员
位置 32: ID 32 (2025-10-23T01:16:46) ✅ 在并列组之后
位置 33: ID 33 (2025-10-23T01:17:25)
...
位置 40: ID 40 (2025-10-27T01:18:52)
位置 41: ID 42 (2025-10-27T03:23:09) ✅ 并列组代表
位置 42: ID 43 (2025-10-27T03:23:26) ✅ 并列组成员
位置 43: ID 44 (2025-10-27T03:46:48) ✅ 在并列组之后
位置 44: ID 45 (2025-10-27T09:32:29)
```

### 其他排序模式

**更新时间排序**、**截止日期排序**等都会正确工作：
- 所有待办按对应字段全局排序
- 并列组按其代表的字段值插入
- 组内成员紧随其后

## 技术总结

### 修复前的问题

| 待办类型 | 分组键 | 代表选择 | 全局排序 |
|---------|-------|---------|---------|
| 有并列关系 | `Set{id1, id2}` | 从 `representatives` | ✅ 正确 |
| 无并列关系 | `null`（共享） | `todosA[0]` | ❌ 错误 |

**问题**：所有无并列待办作为一个大组，无法独立排序。

### 修复后的效果

| 待办类型 | 分组键 | 代表选择 | 全局排序 |
|---------|-------|---------|---------|
| 有并列关系 | `Set{id1, id2}` | 从 `allRepresentatives` | ✅ 正确 |
| 无并列关系 | `Set{id}`（独立） | 从 `allRepresentatives`（自己） | ✅ 正确 |

**改进**：每个待办都有独立的分组和代表，可以独立参与全局排序。

## 验证方法

### 测试 1：创建时间升序
1. 创建多个待办，部分有并列关系
2. 按创建时间升序排序
3. **预期**：所有待办按创建时间从早到晚，并列组按代表时间插入

### 测试 2：创建时间降序
1. 按创建时间降序排序
2. **预期**：所有待办按创建时间从晚到早，并列组按代表时间插入

### 测试 3：更新时间排序
1. 修改部分待办
2. 按更新时间排序
3. **预期**：所有待办按更新时间排序，并列组正确插入

### 测试 4：手动排序
1. 设置不同序号
2. 切换到手动排序
3. **预期**：仍然正常工作（不受此修复影响）

## 相关文件

- `src/renderer/utils/sortWithGroups.ts` - 分组排序工具函数（本次修复）
- `src/renderer/App.tsx` - 调用分组排序逻辑
- `src/renderer/components/TodoList.tsx` - 显示排序结果

## 历史修复记录

这是 `sortWithGroups.ts` 的第 4 次重大修复：

1. **第 1 次**：优化代表选择策略，使用比较器选择代表
2. **第 2 次**：组内排序使用比较器，替代固定 ID 排序
3. **第 3 次**：对无分组待办也进行排序
4. **第 4 次**（本次）：每个非并列待办独立成组，确保全局排序正确

经过这些修复，排序逻辑已经完全正确和统一。
