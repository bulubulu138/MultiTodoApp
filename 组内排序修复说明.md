# 组内排序修复说明

## 修复日期
2025-10-28

## 问题描述

### 问题 1：手动排序模式下序号小的被排到最后

**现象**：在手动排序模式下，用户给待办设置序号后，序号为 1 的待办被排到了序号为 4、5、7、8 的后面。

**日志证据**：
```
sorted (有序号):
0: {id: 31, order: 4}
1: {id: 34, order: 4}
2: {id: 43, order: 5}
3: {id: 45, order: 7}
4: {id: 44, order: 8}
5: {id: 33, order: 1}  ❌ 应该排在第一位！
```

**期望排序**：
```
0: {id: 33, order: 1}  ✅ 序号最小，排第一
1: {id: 31, order: 4}
2: {id: 34, order: 4}
3: {id: 43, order: 5}
4: {id: 45, order: 7}
5: {id: 44, order: 8}
```

### 问题 2：时间排序模式下并列待办组内顺序错误

**现象**：在创建时间降序排序模式下，并列分组内的待办顺序与时间顺序不一致。

**并列分组 31 和 34**：
- todo 31: 创建时间 `2025-10-23T01:13:19.094Z`（早）
- todo 34: 创建时间 `2025-10-23T01:39:59.865Z`（晚）

**实际排序**（创建时间降序）：
```
位置 20: {id: 31, createdAt: '...01:13:19'}  ❌ 时间早的在前
位置 21: {id: 34, createdAt: '...01:39:59'}  ❌ 时间晚的在后
```

**期望排序**：
```
位置 20: {id: 34, createdAt: '...01:39:59'}  ✅ 时间晚的在前
位置 21: {id: 31, createdAt: '...01:13:19'}  ✅ 时间早的在后
```

## 根本原因

在 `src/renderer/utils/sortWithGroups.ts` 的 `sortWithGroups` 函数中，组内排序逻辑**固定按 ID 排序**：

```typescript
// 2. 组内按 ID 排序（保持稳定顺序）
for (const [group, todoList] of grouped) {
  if (group) {
    todoList.sort((a, b) => (a.id || 0) - (b.id || 0));  // ❌ 问题代码
  }
}
```

**问题分析**：
1. `sortWithGroups` 函数接受一个 `compareFn` 参数，用于控制排序规则
2. 但在组内排序时，**完全忽略了** `compareFn`，而是固定使用 `(a.id || 0) - (b.id || 0)` 按 ID 排序
3. 这导致：
   - **手动排序模式**：传入的比较器是按 `displayOrders[activeTab]` 排序，但组内仍按 ID 排序，导致序号小的被排到后面
   - **时间排序模式**：传入的比较器是按 `createdAt` 排序，但组内仍按 ID 排序，导致时间早晚和位置不匹配

## 修复方案

### 修改内容

**文件**: `src/renderer/utils/sortWithGroups.ts`（line 107-112）

**修改前**：
```typescript
// 2. 组内按 ID 排序（保持稳定顺序）
for (const [group, todoList] of grouped) {
  if (group) {
    todoList.sort((a, b) => (a.id || 0) - (b.id || 0));
  }
}
```

**修改后**：
```typescript
// 2. 组内也使用比较器排序（确保手动模式按序号、时间模式按时间）
for (const [group, todoList] of grouped) {
  if (group) {
    todoList.sort(compareFn);
  }
}
```

### 修复原理

现在组内和组间都使用**相同的比较器** `compareFn`：

| 排序模式 | 比较器逻辑 | 组间排序 | 组内排序 |
|---------|----------|---------|---------|
| 手动排序 | 按 `displayOrders[activeTab]`，相同序号按 ID | 按代表的序号 | 按序号（修复后） |
| 创建时间-升序 | 按 `createdAt` 升序 | 按代表的创建时间 | 按创建时间（修复后） |
| 创建时间-降序 | 按 `createdAt` 降序 | 按代表的创建时间 | 按创建时间（修复后） |
| 更新时间-升序 | 按 `updatedAt` 升序 | 按代表的更新时间 | 按更新时间（修复后） |
| 更新时间-降序 | 按 `updatedAt` 降序 | 按代表的更新时间 | 按更新时间（修复后） |
| 截止时间-升序 | 按 `deadline` 升序 | 按代表的截止时间 | 按截止时间（修复后） |
| 截止时间-降序 | 按 `deadline` 降序 | 按代表的截止时间 | 按截止时间（修复后） |

**关键改进**：
- 组内和组间排序规则**完全一致**
- 并列待办在组内的顺序符合整体排序逻辑
- 不再有"组内固定按 ID 排序"的特殊处理

## 验证方法

### 验证 1：手动排序模式

1. 切换到"手动排序"模式
2. 给几个待办设置不同的序号（例如 1、4、5、7、8）
3. **预期结果**：
   - 序号 1 的待办排在最前面
   - 序号按从小到大排列
   - 相同序号的待办按 ID 排序

### 验证 2：创建时间降序排序

1. 切换到"创建时间-降序"模式
2. 找到有并列关系的两个待办
3. 查看它们的创建时间
4. **预期结果**：
   - 创建时间晚的在前
   - 创建时间早的在后
   - 组内顺序与整体时间降序一致

### 验证 3：并列分组保持

1. 在任何排序模式下
2. 有并列关系的待办应该始终相邻显示
3. **预期结果**：
   - 并列待办不会被拆散
   - 组内顺序符合当前排序规则
   - 组的位置由组代表决定

## 技术总结

这次修复的核心是**统一组内和组间的排序规则**：

### 修复前
- **组间排序**：使用传入的 `compareFn`，按排序规则排序
- **组内排序**：固定按 ID 排序，忽略排序规则
- **结果**：组内顺序与整体排序逻辑不一致

### 修复后
- **组间排序**：使用传入的 `compareFn`，按排序规则排序
- **组内排序**：**同样使用** `compareFn`，按排序规则排序
- **结果**：组内和整体排序逻辑完全一致

### 排序流程（修复后）

1. **构建分组**：将所有待办按并列关系分组
2. **选择代表**：每组根据 `compareFn` 选择最优的待办作为代表
3. **组内排序**：每组内部使用 `compareFn` 排序
4. **组间排序**：各组之间根据代表使用 `compareFn` 排序
5. **展平返回**：将排序后的组展平为一维数组

这样确保了从局部（组内）到整体（组间）的排序规则完全一致。

## 相关文件

- `src/renderer/utils/sortWithGroups.ts` - 分组排序工具函数（本次修复）
- `src/renderer/App.tsx` - 调用分组排序逻辑
- `src/renderer/components/TodoList.tsx` - 显示排序结果

## 后续测试

等待 GitHub Actions 构建完成后，重点测试：
1. **手动排序**：序号小的是否排在前面
2. **时间排序**：并列组内是否按时间排序
3. **并列分组**：是否始终保持在一起
4. **多 Tab**：不同 tab 的排序是否独立正确

