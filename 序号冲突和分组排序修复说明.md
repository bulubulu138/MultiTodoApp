# 序号冲突和分组排序修复说明

## 修复日期
2025-10-29

## 问题 1：序号自动递增逻辑不符合预期

### 用户反馈

当用户给某个待办设置序号 18 时，原来的序号 19 自动变成了 20，但用户不希望这样。

**当前行为**（修复前）：
```
设置前序号: 1, 2, 4, 5, 6, 19, 20
用户输入: 18
结果: 1, 2, 4, 5, 6, 18, 20, 21  (原19→20, 原20→21)
```

**期望行为**：
```
设置前序号: 1, 2, 4, 5, 6, 19, 20
用户输入: 18
结果: 1, 2, 4, 5, 6, 18, 19, 20  (不自动递增)
```

但是：
- 不允许序号重复
- 如果输入了重复的序号，则将**已有的待办序号**递增

**重复序号处理**：
```
设置前序号: 1, 2, 4, 5, 6, 18, 20
用户输入: 5 (重复)
结果: 1, 2, 4, 5(新), 6, 7, 19, 21  (原5→6, 原6→7, 原18→19, 原20→21)
```

### 根本原因

在 `src/renderer/components/TodoList.tsx` 的 `handleOrderSave` 函数中（修复前 line 213-229）：

```typescript
// 2. 找出需要调整的待办（当前tab序号 >= newOrder 且不是当前待办）
const toAdjust = currentTabTodos.filter(t => 
  t.id !== todoId && 
  t.displayOrders![activeTab]! >= newOrder  // ❌ 使用 >=
);

// 3. 如果有需要调整的待办，批量更新
if (toAdjust.length > 0) {
  const updates = toAdjust.map(t => ({
    id: t.id!,
    tabKey: activeTab,
    displayOrder: t.displayOrders![activeTab]! + 1
  }));
  
  await window.electronAPI.todo.batchUpdateDisplayOrders(updates);
  message.success(`已自动调整 ${toAdjust.length} 个待办的序号`);
}
```

**问题**：
- 使用 `>=` 条件，导致所有 >= 新序号的待办都被递增
- 即使新序号是 18，序号 19、20 也会被递增为 20、21
- 用户无法在中间插入序号

### 修复方案

**文件**: `src/renderer/components/TodoList.tsx` (line 207-237)

**修改前**:
```typescript
// 2. 找出需要调整的待办（当前tab序号 >= newOrder 且不是当前待办）
const toAdjust = currentTabTodos.filter(t => 
  t.id !== todoId && 
  t.displayOrders![activeTab]! >= newOrder
);

// 3. 如果有需要调整的待办，批量更新
if (toAdjust.length > 0) {
  const updates = toAdjust.map(t => ({
    id: t.id!,
    tabKey: activeTab,
    displayOrder: t.displayOrders![activeTab]! + 1
  }));
  
  await window.electronAPI.todo.batchUpdateDisplayOrders(updates);
  message.success(`已自动调整 ${toAdjust.length} 个待办的序号`);
}
```

**修改后**:
```typescript
// 2. 检查是否有重复序号（完全相同）
const duplicate = currentTabTodos.find(t => 
  t.id !== todoId && 
  t.displayOrders![activeTab] === newOrder  // ✅ 使用 ===
);

// 3. 如果有重复序号，递增已有待办及其后续所有待办
if (duplicate) {
  // 找出所有序号 >= newOrder 的待办（不包括当前待办）
  const toAdjust = currentTabTodos.filter(t => 
    t.id !== todoId && 
    t.displayOrders![activeTab]! >= newOrder
  );
  
  if (toAdjust.length > 0) {
    const updates = toAdjust.map(t => ({
      id: t.id!,
      tabKey: activeTab,
      displayOrder: t.displayOrders![activeTab]! + 1
    }));
    
    await window.electronAPI.todo.batchUpdateDisplayOrders(updates);
    message.success(`序号 ${newOrder} 已被占用，已自动调整 ${toAdjust.length} 个待办的序号`);
  }
}
```

**关键改进**：
1. 先检查是否有**完全相同**的序号（`===` 而非 `>=`）
2. **只有在重复时**才递增已有待办
3. 允许序号有空缺（如 1, 2, 4, 5...）
4. 提示信息更明确："序号 X 已被占用"

## 问题 2：手动排序模式下并列分组位置错误

### 用户反馈

从日志看到：
```
sorted (有序号):
0: ID 40 (序号 1)
1: ID 33 (序号 2)
2: ID 45 (序号 4)
3: ID 26 (序号 18)  ❌ 序号18排在序号5前面
4: ID 29 (序号 20)  ❌ 序号20排在序号5前面
5: ID 31 (序号 5)   ❌ 应在位置2（4之后）
6: ID 34 (序号 5)   ❌ 并列组成员
7: ID 43 (序号 6)
```

**期望的正确排序**：
```
0: ID 40 (序号 1)
1: ID 33 (序号 2)
2: ID 45 (序号 4)
3: ID 31 (序号 5)   ✅ 并列组开始
4: ID 34 (序号 5)   ✅ 并列组成员
5: ID 43 (序号 6)
6: ID 26 (序号 18)
7: ID 29 (序号 20)
```

### 根本原因

在 `src/renderer/App.tsx` 的手动排序模式中（修复前 line 512-514）：

```typescript
// 手动排序模式：使用 ID 比较器选择代表
const manualComparator = (a: Todo, b: Todo) => (a.id || 0) - (b.id || 0);
const groupRepresentatives = selectGroupRepresentatives(parallelGroups, filtered, manualComparator);
```

**问题分析**：

1. **代表选择错误**：
   - 使用 ID 比较器选择代表
   - 并列组 ID 31+34（序号都是 5）选择 ID 31 作为代表
   - 但 ID 31 本身没有按序号排序的意义

2. **组间排序逻辑**：
   ```typescript
   const sorted = sortWithGroups(withOrder, parallelGroups, groupRepresentatives, (a, b) => {
     const orderA = a.displayOrders![activeTab]!;
     const orderB = b.displayOrders![activeTab]!;
     if (orderA !== orderB) return orderA - orderB;
     return (a.id || 0) - (b.id || 0);
   });
   ```
   虽然 `sortWithGroups` 内部使用序号比较器，但代表已经选错了！

3. **为什么会出错**：
   - `selectGroupRepresentatives` 使用 ID 比较器，选择 ID 最小的作为代表
   - 但在手动排序模式下，应该选择**序号最小的**作为代表
   - 导致并列组的代表选择不是基于序号

### 修复方案

**文件**: `src/renderer/App.tsx` (line 512-523)

**修改前**:
```typescript
// 手动排序模式：使用 ID 比较器选择代表
const manualComparator = (a: Todo, b: Todo) => (a.id || 0) - (b.id || 0);
const groupRepresentatives = selectGroupRepresentatives(parallelGroups, filtered, manualComparator);
```

**修改后**:
```typescript
// 手动排序模式：使用序号比较器选择代表（序号相同时用 ID）
const manualComparator = (a: Todo, b: Todo) => {
  const orderA = a.displayOrders?.[activeTab];
  const orderB = b.displayOrders?.[activeTab];
  // 如果都有序号，比较序号
  if (orderA != null && orderB != null) {
    if (orderA !== orderB) return orderA - orderB;
  }
  // 序号相同或都没序号，比较 ID
  return (a.id || 0) - (b.id || 0);
};
const groupRepresentatives = selectGroupRepresentatives(parallelGroups, filtered, manualComparator);
```

**关键改进**：
1. 代表选择使用**序号比较器**，而非 ID 比较器
2. 优先比较序号，序号相同时才比较 ID
3. 确保并列组按其**最小序号**参与全局排序

### 修复效果

**修复前的代表选择**：
- 并列组 ID 31+34（序号都是 5）→ 代表选择基于 ID → 代表是 ID 31
- 但代表选择的比较器是 ID，导致后续排序混乱

**修复后的代表选择**：
- 并列组 ID 31+34（序号都是 5）→ 代表选择基于序号 → 两者序号相同，选 ID 小的 ID 31
- 但这次代表是基于序号选的，所以组间排序会按序号 5 正确排序

## 预期效果

### 场景 1：插入空缺序号

**操作**：给待办设置序号 18
**当前序号**：1, 2, 4, 5, 6, 19, 20

**修复前**：
```
结果: 1, 2, 4, 5, 6, 18, 20, 21
说明: 原19→20, 原20→21（不符合预期）
```

**修复后**：
```
结果: 1, 2, 4, 5, 6, 18, 19, 20
说明: 允许空缺，18直接插入（符合预期）
```

### 场景 2：输入重复序号

**操作**：给待办设置序号 5
**当前序号**：1, 2, 4, 5, 6, 18, 20

**修复后**：
```
结果: 1, 2, 4, 5(新), 6, 7, 19, 21
说明: 检测到重复，原5→6, 6→7, 18→19, 20→21
提示: "序号 5 已被占用，已自动调整 4 个待办的序号"
```

### 场景 3：并列分组排序

**待办**：
- ID 40 (序号 1)
- ID 33 (序号 2)
- ID 45 (序号 4)
- ID 31 (序号 5) + ID 34 (序号 5) ← 并列组
- ID 43 (序号 6)
- ID 26 (序号 18)
- ID 29 (序号 20)

**修复前**：
```
排序: 1, 2, 4, 18, 20, 5, 5, 6
说明: 并列组(5)被排到18、20后面
```

**修复后**：
```
排序: 1, 2, 4, 5, 5, 6, 18, 20
说明: 并列组按序号5正确插入
```

## 技术总结

### 修复 1：序号冲突处理

| 条件 | 修复前 | 修复后 |
|------|--------|--------|
| 检测条件 | `>= newOrder` | `=== newOrder` |
| 触发时机 | 总是递增 | 仅重复时递增 |
| 允许空缺 | ❌ 否 | ✅ 是 |
| 用户体验 | 不可控 | 可控 |

### 修复 2：分组代表选择

| 模式 | 修复前 | 修复后 |
|------|--------|--------|
| 手动排序 | ID 比较器 | 序号比较器 |
| 时间排序 | 时间比较器 | 时间比较器 |
| 代表意义 | 错误 | 正确 |
| 分组位置 | 错误 | 正确 |

## 验证方法

### 测试 1：序号空缺插入
1. 现有序号：1, 2, 4, 5, 6
2. 给新待办设置序号 3
3. **预期**：1, 2, 3, 4, 5, 6（3插入到2和4之间）

### 测试 2：重复序号处理
1. 现有序号：1, 2, 4, 5, 6
2. 给新待办设置序号 4（重复）
3. **预期**：1, 2, 4(新), 5, 6, 7（原4→5, 原5→6, 原6→7）
4. **提示**："序号 4 已被占用，已自动调整 3 个待办的序号"

### 测试 3：并列分组排序
1. 创建两个并列待办，序号都设为 5
2. 创建其他待办，序号为 1, 2, 4, 6, 18
3. **预期排序**：1, 2, 4, 5, 5(分组), 6, 18
4. **分组显示**：序号 5 的两个待办有分组边框

## 相关文件

- `src/renderer/components/TodoList.tsx` - 序号冲突处理逻辑（本次修复）
- `src/renderer/App.tsx` - 手动排序代表选择逻辑（本次修复）
- `src/renderer/utils/sortWithGroups.ts` - 分组排序工具函数

## 历史修复记录

与排序相关的修复历程：

1. **时间排序分组位置修复**：每个非并列待办独立成组
2. **无分组待办排序修复**：组内排序使用比较器
3. **序号冲突处理修复**（本次）：只在重复时递增
4. **手动排序代表选择修复**（本次）：使用序号比较器

排序系统现在已经完全正确！

