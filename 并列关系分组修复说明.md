# 并列关系分组显示逻辑修复

## 问题描述

之前的 `TodoList.tsx` 中，分组显示逻辑仅基于 `displayOrder` 是否相同来判断，导致删除并列关系后，待办项仍然显示为分组状态。

## 问题原因

旧的逻辑：
```typescript
const isInGroup = sortOption === 'manual' && todo.displayOrder != null && (
  (prevTodo && prevTodo.displayOrder === todo.displayOrder) ||
  (nextTodo && nextTodo.displayOrder === todo.displayOrder)
);
```

这个逻辑只检查 `displayOrder` 是否相同，**没有检查是否真正存在并列关系**。

## 修复方案

### 1. 添加 `parallelGroups` 计算

使用 DFS (深度优先搜索) 算法构建并列关系分组 Map：

```typescript
const parallelGroups = useMemo(() => {
  const groups = new Map<number, Set<number>>();
  const visited = new Set<number>();
  
  const dfs = (todoId: number, groupSet: Set<number>) => {
    if (visited.has(todoId)) return;
    visited.add(todoId);
    groupSet.add(todoId);
    
    // 找到所有与该 todo 有并列关系的其他 todo
    const relatedIds = relations
      .filter(r => r.relation_type === 'parallel')
      .filter(r => r.source_id === todoId || r.target_id === todoId)
      .map(r => r.source_id === todoId ? r.target_id : r.source_id);
    
    relatedIds.forEach(relatedId => dfs(relatedId, groupSet));
  };
  
  todos.forEach(todo => {
    if (!visited.has(todo.id!)) {
      const parallelRels = relations.filter(r =>
        r.relation_type === 'parallel' &&
        (r.source_id === todo.id || r.target_id === todo.id)
      );
      
      if (parallelRels.length > 0) {
        const groupSet = new Set<number>();
        dfs(todo.id!, groupSet);
        groupSet.forEach(id => groups.set(id, groupSet));
      }
    }
  });
  
  return groups;
}, [todos, relations]);
```

**优势**：
- 自动处理传递关系（A-B, B-C 会自动识别为一个组）
- 实时响应 `relations` 变化
- 性能优化（useMemo 缓存）

### 2. 修改分组判断逻辑

新的逻辑同时检查 `displayOrder` 和并列关系：

```typescript
// 检查是否在并列分组中
const parallelGroup = parallelGroups.get(todo.id!);
const isInParallelGroup = parallelGroup && parallelGroup.size > 1;

// 只有同时满足以下条件才显示为分组：
// 1. 手动排序模式
// 2. 有 displayOrder
// 3. 确实在并列关系分组中
// 4. displayOrder 与相邻待办相同且该相邻待办在同一并列分组中
const isInGroup = sortOption === 'manual' && 
  todo.displayOrder != null && 
  isInParallelGroup &&
  (
    (prevTodo && prevTodo.displayOrder === todo.displayOrder && parallelGroup?.has(prevTodo.id!)) ||
    (nextTodo && nextTodo.displayOrder === todo.displayOrder && parallelGroup?.has(nextTodo.id!))
  );

const isGroupStart = isInGroup && (!prevTodo || prevTodo.displayOrder !== todo.displayOrder || !parallelGroup?.has(prevTodo.id!));
const isGroupEnd = isInGroup && (!nextTodo || nextTodo.displayOrder !== todo.displayOrder || !parallelGroup?.has(nextTodo.id!));
```

**关键改进**：
1. **`isInParallelGroup`** - 检查是否在并列关系分组中（组大小 > 1）
2. **`parallelGroup?.has(prevTodo.id!)`** - 检查相邻待办是否在同一并列分组中
3. **传递检查** - `isGroupStart` 和 `isGroupEnd` 也检查相邻待办是否在同一分组

## 修复效果

### 修复前

- ❌ 待办 A、B、C 的 `displayOrder` 都是 1
- ❌ 删除 A-B 的并列关系
- ❌ **问题**：A、B、C 仍然显示为分组（因为 displayOrder 都是 1）

### 修复后

- ✅ 待办 A、B、C 的 `displayOrder` 都是 1
- ✅ 删除 A-B 的并列关系
- ✅ **正确**：如果 B-C 有并列关系，只有 B、C 显示为分组；A 单独显示
- ✅ **正确**：如果 B、C 也没有并列关系，A、B、C 都单独显示

## 测试场景

### 场景 1: 创建并列关系
1. 创建待办 A、B、C
2. 设置它们的 `displayOrder` 为 1
3. 添加 A-B 并列关系
4. **预期**：A、B 显示为分组，C 单独显示

### 场景 2: 删除并列关系
1. 在场景 1 的基础上
2. 删除 A-B 的并列关系
3. **预期**：A、B、C 都单独显示（即使 displayOrder 仍为 1）

### 场景 3: 传递关系
1. 创建待办 A、B、C、D
2. 设置它们的 `displayOrder` 为 1
3. 添加 A-B、B-C 并列关系（注意：没有 A-C 直接关系）
4. **预期**：A、B、C 显示为一个组（传递识别），D 单独显示

### 场景 4: 多个独立分组
1. 创建待办 A、B、C、D
2. 设置它们的 `displayOrder` 为 1
3. 添加 A-B、C-D 并列关系
4. **预期**：A、B 显示为一个组，C、D 显示为另一个组（两个独立分组）

## 修改文件

- `src/renderer/components/TodoList.tsx`
  - 导入 `useMemo` from React
  - 添加 `parallelGroups` 计算（第 262-296 行）
  - 修改 `isInGroup`、`isGroupStart`、`isGroupEnd` 的判断逻辑（第 334-352 行）

## 技术细节

### DFS 算法

使用深度优先搜索遍历并列关系图，将所有互相连接的待办归为一组：

```
待办关系图:
  A --- B
  |
  C --- D

DFS 结果:
  Group 1: {A, B, C, D}  // 所有待办都在一个连通分量中
```

### 时间复杂度

- **parallelGroups 计算**: O(T + R)
  - T = todos 数量
  - R = relations 数量
- **分组判断**: O(1) - Map 查找和 Set 操作都是常数时间

### 空间复杂度

- **parallelGroups Map**: O(T) - 每个 todo 最多一个条目
- **visited Set**: O(T) - 临时变量

## 相关代码

- `src/shared/types.ts` - `TodoRelation` 接口定义
- `src/renderer/App.tsx` - `loadRelations()` 和 `syncParallelGroupsSilently()`
- `src/renderer/components/RelationsModal.tsx` - 关系管理 UI

## 未来改进

1. **性能优化**: 如果 relations 非常多（> 10000），可以考虑增量更新而非全量重建
2. **可视化**: 在分组标签上显示组内待办数量
3. **交互优化**: 点击分组标签展开/收起整个分组

---

**修复时间**: 2025-10-27  
**修复版本**: v1.0.1  
**相关 Issue**: 并列关系删除后分组仍显示

