# 所有排序模式分组显示修复说明

## 修复日期
2025-10-28

## 问题描述

### 用户反馈
在创建时间降序排序等非手动排序模式下，有并列关系的待办事项没有显示分组边框和样式。

**具体现象**：
- 手动排序模式：有分组显示（但要求相同序号）
- 创建时间排序：无分组显示
- 更新时间排序：无分组显示
- 截止时间排序：无分组显示

### 用户需求
**选项 C**：强制让并列待办相邻，排序时取分组中第一个待办的属性。

即：
1. 并列待办在**所有排序模式**下都应该相邻显示
2. 只要有并列关系就显示分组边框，**无需额外条件**（如相同序号）
3. 组的位置由组内第一个待办（组代表）的属性决定

## 根本原因

### 问题 1：分组判断只在手动模式生效

在 `TodoList.tsx` 中，分组判断逻辑限制了排序模式：

```typescript
const isInGroup = sortOption === 'manual' &&  // ❌ 只有手动模式
  currentDisplayOrder != null && 
  isInParallelGroup &&
  ...
```

**结果**：在时间排序等模式下，即使有并列关系也不显示分组。

### 问题 2：手动模式还要求相同序号

```typescript
const isInGroup = sortOption === 'manual' && 
  currentDisplayOrder != null &&  // ❌ 要求有序号
  isInParallelGroup &&
  (
    (prevTodo && prevDisplayOrder === currentDisplayOrder && ...) ||  // ❌ 要求相同序号
    (nextTodo && nextDisplayOrder === currentDisplayOrder && ...)
  );
```

**结果**：即使在手动排序模式，也只有设置了相同序号的并列待办才显示分组。

## 修复方案

### 核心修改：统一所有排序模式的分组规则

**文件**: `src/renderer/components/TodoList.tsx`（line 347-365）

**修改前**:
```typescript
// 检查是否在并列分组中
const parallelGroup = parallelGroups.get(todo.id!);
const isInParallelGroup = parallelGroup && parallelGroup.size > 1;

// 获取相邻待办的显示序号
const prevDisplayOrder = prevTodo?.displayOrders?.[activeTab];
const nextDisplayOrder = nextTodo?.displayOrders?.[activeTab];

// 只有同时满足以下条件才显示为分组：
// 1. 手动排序模式
// 2. 有 displayOrder
// 3. 确实在并列关系分组中
// 4. displayOrder 与相邻待办相同且该相邻待办在同一并列分组中
const isInGroup = sortOption === 'manual' && 
  currentDisplayOrder != null && 
  isInParallelGroup &&
  (
    (prevTodo && prevDisplayOrder === currentDisplayOrder && parallelGroup?.has(prevTodo.id!)) ||
    (nextTodo && nextDisplayOrder === currentDisplayOrder && parallelGroup?.has(nextTodo.id!))
  );

const isGroupStart = isInGroup && (!prevTodo || prevDisplayOrder !== currentDisplayOrder || !parallelGroup?.has(prevTodo.id!));
const isGroupEnd = isInGroup && (!nextTodo || nextDisplayOrder !== currentDisplayOrder || !parallelGroup?.has(nextTodo.id!));

// 调试日志
if (isInGroup) {
  console.log(`Todo ${todo.id} (order=${currentDisplayOrder}): isGroupStart=${isGroupStart}, isGroupEnd=${isGroupEnd}, parallelGroupSize=${parallelGroup?.size}`);
}
```

**修改后**:
```typescript
// 检查是否在并列分组中
const parallelGroup = parallelGroups.get(todo.id!);
const isInParallelGroup = parallelGroup && parallelGroup.size > 1;

// 统一分组判断：所有排序模式下，只要有并列关系且相邻即显示分组
// sortWithGroups 确保并列待办在所有模式下都相邻
const isInGroup = isInParallelGroup &&
  (
    (prevTodo && parallelGroup?.has(prevTodo.id!)) ||
    (nextTodo && parallelGroup?.has(nextTodo.id!))
  );

const isGroupStart = isInGroup && (!prevTodo || !parallelGroup?.has(prevTodo.id!));
const isGroupEnd = isInGroup && (!nextTodo || !parallelGroup?.has(nextTodo.id!));

// 调试日志
if (isInGroup) {
  console.log(`Todo ${todo.id}: isGroupStart=${isGroupStart}, isGroupEnd=${isGroupEnd}, parallelGroupSize=${parallelGroup?.size}, sortOption=${sortOption}`);
}
```

**删除的代码**（不再需要）:
```typescript
// 获取相邻待办的显示序号
const prevDisplayOrder = prevTodo?.displayOrders?.[activeTab];
const nextDisplayOrder = nextTodo?.displayOrders?.[activeTab];
```

## 修复逻辑详解

### 分组判断条件（修复后）

**3 个简单条件**：
1. `isInParallelGroup`：当前待办在并列分组中（组内 ≥2 个待办）
2. `prevTodo && parallelGroup?.has(prevTodo.id!)`：前一个待办在同一分组
3. `nextTodo && parallelGroup?.has(nextTodo.id!)`：后一个待办在同一分组

**分组判断**：
- `isInGroup = true`：满足条件 1 + (条件 2 或 条件 3)

**边界判断**：
- `isGroupStart = true`：在分组中 + 前一个不在同组
- `isGroupEnd = true`：在分组中 + 后一个不在同组

### 为什么可以这样简化

**关键前提**：`sortWithGroups` 函数已确保并列待办在所有排序模式下都相邻。

`sortWithGroups` 的工作流程：
1. **构建分组**：将有并列关系的待办放入同一组
2. **选择代表**：根据比较器选择组代表（时间降序选时间最晚的）
3. **组内排序**：使用比较器排序（确保组内顺序符合整体规则）
4. **组间排序**：根据代表的属性排序
5. **展平输出**：组内待办紧挨着输出

**结果**：
- 并列待办在任何排序模式下都相邻
- 组的位置由组代表的属性决定
- 组内顺序符合当前排序规则

因此，`TodoList.tsx` 只需检查"相邻的待办是否在同一分组"即可。

## 预期效果示例

### 场景 1：手动排序模式（不设置序号）

**数据**：
- todo 31 和 34 有并列关系
- 都没有设置 `displayOrder`

**排序结果**：
```
todo 31 ┌─────┐ isGroupStart=true
todo 34 └─────┘ isGroupEnd=true
```

**说明**：无需设置序号，只要有并列关系就显示分组。

### 场景 2：手动排序模式（不同序号）

**数据**：
- todo 31 和 34 有并列关系
- todo 31 序号 = 1
- todo 34 序号 = 5

**排序结果**：
```
todo 31 (order=1) ┌─────┐ isGroupStart=true
todo 34 (order=5) └─────┘ isGroupEnd=true
```

**说明**：即使序号不同，仍然显示分组（因为有并列关系）。

### 场景 3：创建时间降序排序

**数据**：
- todo 31: `2025-10-23T01:13:19.094Z`（早）
- todo 34: `2025-10-23T01:39:59.865Z`（晚）
- 有并列关系

**排序结果**：
```
todo 34 (01:39:59) ┌─────┐ isGroupStart=true, 组代表（时间晚）
todo 31 (01:13:19) └─────┘ isGroupEnd=true
```

**说明**：
- 组代表是时间最晚的 todo 34
- 组的位置由 todo 34 的创建时间决定
- 组内按时间降序排列

### 场景 4：创建时间升序排序

**数据**：同上

**排序结果**：
```
todo 31 (01:13:19) ┌─────┐ isGroupStart=true, 组代表（时间早）
todo 34 (01:39:59) └─────┘ isGroupEnd=true
```

**说明**：
- 组代表是时间最早的 todo 31
- 组的位置由 todo 31 的创建时间决定
- 组内按时间升序排列

### 场景 5：截止时间降序排序

**数据**：
- todo 20 和 21 有并列关系
- todo 20 截止时间：`2025-11-01`
- todo 21 截止时间：`2025-10-30`

**排序结果**：
```
todo 20 (2025-11-01) ┌─────┐ isGroupStart=true, 组代表（截止晚）
todo 21 (2025-10-30) └─────┘ isGroupEnd=true
```

**说明**：所有排序模式规则一致。

## 技术总结

### 修复前的问题

| 排序模式 | 分组显示 | 额外条件 |
|---------|---------|---------|
| 手动排序 | ✅ 显示 | ❌ 要求相同序号 |
| 创建时间 | ❌ 不显示 | - |
| 更新时间 | ❌ 不显示 | - |
| 截止时间 | ❌ 不显示 | - |

### 修复后的效果

| 排序模式 | 分组显示 | 额外条件 |
|---------|---------|---------|
| 手动排序 | ✅ 显示 | ✅ 无 |
| 创建时间 | ✅ 显示 | ✅ 无 |
| 更新时间 | ✅ 显示 | ✅ 无 |
| 截止时间 | ✅ 显示 | ✅ 无 |

**统一规则**：只要有并列关系且相邻，就显示分组边框。

### 核心设计理念

1. **sortWithGroups 负责相邻性**：确保并列待办在所有排序模式下都相邻
2. **TodoList 负责显示**：只需检查相邻性，显示分组边框
3. **职责分离**：排序逻辑和显示逻辑解耦

## 验证方法

### 测试 1：手动排序模式（无序号）
1. 创建两个有并列关系的待办
2. 不设置序号
3. 切换到"手动排序"模式
4. **预期**：显示分组边框

### 测试 2：手动排序模式（不同序号）
1. 给上述两个待办设置不同序号（如 1 和 5）
2. **预期**：仍然显示分组边框

### 测试 3：创建时间降序
1. 切换到"创建时间-降序"
2. **预期**：时间晚的在前，显示分组边框

### 测试 4：创建时间升序
1. 切换到"创建时间-升序"
2. **预期**：时间早的在前，显示分组边框

### 测试 5：切换排序模式
1. 在各种排序模式之间切换
2. **预期**：所有模式下都显示分组边框

## 相关文件

- `src/renderer/components/TodoList.tsx` - 分组显示逻辑（本次修复）
- `src/renderer/utils/sortWithGroups.ts` - 分组排序逻辑（已修复）
- `src/renderer/App.tsx` - 调用分组排序

## 后续建议

考虑在界面上增加分组标识，例如：
- 分组序号显示（如"分组 #1"）
- 分组颜色标记
- 分组折叠/展开功能

这些可以作为后续的功能增强。

